<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="https://coffeetimes.github.io/jekyll-theme-yat/feed.xml" rel="self" type="application/atom+xml" /><link href="https://coffeetimes.github.io/jekyll-theme-yat/" rel="alternate" type="text/html" /><updated>2025-07-29T01:24:20+00:00</updated><id>https://coffeetimes.github.io/jekyll-theme-yat/feed.xml</id><title type="html">TechBlog</title><subtitle>Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.</subtitle><author><name>KIM-KYOUNG-OH</name></author><entry><title type="html">if-else는 이제 그만, 전략 패턴으로 코드 개선하기</title><link href="https://coffeetimes.github.io/jekyll-theme-yat/design-pattern/2025/07/27/if-else-explosion.html" rel="alternate" type="text/html" title="if-else는 이제 그만, 전략 패턴으로 코드 개선하기" /><published>2025-07-27T00:00:00+00:00</published><updated>2025-07-27T00:00:00+00:00</updated><id>https://coffeetimes.github.io/jekyll-theme-yat/design-pattern/2025/07/27/if-else-explosion</id><content type="html" xml:base="https://coffeetimes.github.io/jekyll-theme-yat/design-pattern/2025/07/27/if-else-explosion.html"><![CDATA[<p>개발자라면 한 번쯤은 <code class="language-plaintext highlighter-rouge">if-else</code> 문으로 가득한 클래스를 만들어본 적이 있을 겁니다.<br />
하지만 시간이 지나고 코드가 커질수록, 우리는 더 깔끔하고 유연한 구조를 원하게 됩니다.<br />
이번 포스팅에서 <code class="language-plaintext highlighter-rouge">if-else</code> 코드를 줄이면서 코드를 단순하고 유지보수에 유리한 구조로 변경하는 방법을 알아 보겠습니다.</p>

<h2 id="if-else-지옥">if-else 지옥</h2>
<p>간단한 예시부터 시작해보겠습니다.<br />
당신은 배송 서비스를 개발 중이고, 현재는 도보, 트럭, 기차 세 가지 배송 수단을 지원하고 있습니다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">DeliveryService</span> <span class="o">{</span> 
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">delivery</span> <span class="o">(</span><span class="nc">String</span> <span class="n">deliveryType</span><span class="o">)</span> <span class="o">{</span> 
        <span class="k">if</span> <span class="o">(</span><span class="s">"WALK"</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">deliveryType</span><span class="o">))</span> <span class="o">{</span> 
            <span class="c1">// 도보</span>
         <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="s">"TRUCK"</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">deliveryType</span><span class="o">))</span> <span class="o">{</span> 
            <span class="c1">// 트럭</span>
         <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="s">"TRAIN"</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">deliveryType</span><span class="o">))</span> <span class="o">{</span> 
            <span class="c1">// 기차</span>
         <span class="o">}</span> 
    <span class="o">}</span> 
<span class="o">}</span>
</code></pre></div></div>
<p>그런데 어느날 기획팀에서 이렇게 말합니다.<br />
“배송수단 선박, 항공을 추가할 수 있을까요?”</p>

<p>이제 여러분의 클래스는 <code class="language-plaintext highlighter-rouge">else if</code> 블록이 계속 추가되며 점점 복잡해집니다.<br />
처음에는 단순했던 로직이 어느새 거대한 조건 분기문으로 뒤덮이게 되죠.</p>

<h3 id="if-else-방식의-문제점">if-else 방식의 문제점</h3>
<ul>
  <li>조건이 늘어날수록 로직이 복잡해지고 유지보수가 어려워짐</li>
  <li>새로운 타입이 생길 때마다 기존 코드를 수정해야 함 → OCP 위반</li>
  <li>테스트, 가독성, 확장성 모두 악화</li>
</ul>

<p>이제는 if-else 지옥에서 벗어나 더 유연하고 확장 가능한 구조로 나아갈 때입니다.<br />
바로, <strong>전략 패턴(Strategy Pattern)</strong> 을 통해 말이죠.</p>

<h2 id="전략-패턴으로-구조-개선하기">전략 패턴으로 구조 개선하기</h2>

<p>전략 패턴(Strategy Pattern)은 알고리즘(또는 행위)을 캡슐화하여 여러 개의 알고리즘을 상호 교환 가능하게 만들고, 실행 시점에 적절한 알고리즘을 선택할 수 있도록 하는 디자인 패턴입니다.</p>

<p>즉, <strong>“어떤 작업을 수행하는 방법(전략)을 클래스로 분리하고, 필요에 따라 해당 전략을 동적으로 바꿔가며 사용할 수 있게 하는 패턴”</strong> 입니다.</p>

<p>이를 통해 조건문 분기를 줄이고, 확장성과 유지보수성을 높일 수 있습니다.</p>

<h2 id="1전략-인터페이스-정의">1.전략 인터페이스 정의</h2>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">DeliveryStrategy</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">deliver</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="2각-타입별-전략-클래스-구현">2.각 타입별 전략 클래스 구현</h2>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Component</span><span class="o">(</span><span class="s">"WALK"</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">WalkDeliveryStrategy</span> <span class="kd">implements</span> <span class="nc">DeliveryStrategy</span> <span class="o">{</span>
  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">deliver</span><span class="o">()</span> <span class="o">{</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"도보로 배송합니다."</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="nd">@Component</span><span class="o">(</span><span class="s">"TRUCK"</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">TruckDeliveryStrategy</span> <span class="kd">implements</span> <span class="nc">DeliveryStrategy</span> <span class="o">{</span>
  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">deliver</span><span class="o">()</span> <span class="o">{</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"트럭으로 배송합니다."</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="nd">@Component</span><span class="o">(</span><span class="s">"TRAIN"</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">TrainDeliveryStrategy</span> <span class="kd">implements</span> <span class="nc">DeliveryStrategy</span> <span class="o">{</span>
  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">deliver</span><span class="o">()</span> <span class="o">{</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"기차로 배송합니다."</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="nd">@Component</span><span class="o">(</span><span class="s">"SHIP"</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ShipDeliveryStrategy</span> <span class="kd">implements</span> <span class="nc">DeliveryStrategy</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">deliver</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"선박으로 배송합니다."</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="nd">@Component</span><span class="o">(</span><span class="s">"AIRPLANE"</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">AirplaneDeliveryStrategy</span> <span class="kd">implements</span> <span class="nc">DeliveryStrategy</span> <span class="o">{</span>
  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">deliver</span><span class="o">()</span> <span class="o">{</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"항공으로 배송합니다."</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="3전략을-직접-주입받아-사용하는-서비스-클래스">3.전략을 직접 주입받아 사용하는 서비스 클래스</h2>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Service</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">DeliveryService</span> <span class="o">{</span>
    
    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">DeliveryStrategy</span><span class="o">&gt;</span> <span class="n">strategyMap</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">DeliveryService</span><span class="o">(</span><span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">DeliveryStrategy</span><span class="o">&gt;</span> <span class="n">strategyMap</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">strategyMap</span> <span class="o">=</span> <span class="n">strategyMap</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">deliver</span><span class="o">(</span><span class="nc">String</span> <span class="n">deliveryType</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">DeliveryStrategy</span> <span class="n">strategy</span> <span class="o">=</span> <span class="n">strategyMap</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">deliveryType</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">strategy</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalArgumentException</span><span class="o">(</span><span class="s">"지원하지 않는 배송 타입: "</span> <span class="o">+</span> <span class="n">deliveryType</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="n">strategy</span><span class="o">.</span><span class="na">deliver</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="전략-패턴-도입-전후-비교">전략 패턴 도입 전후 비교</h2>

<table>
  <thead>
    <tr>
      <th>항목</th>
      <th>if-else 방식</th>
      <th>전략 패턴 방식</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>**유지보수 및 확장성**</td>
      <td>❌ 새로운 조건 추가 시 기존 코드 수정 필요</td>
      <td>✅ 기존 코드는 그대로, 클래스만 추가하면 됨</td>
    </tr>
    <tr>
      <td>**가독성**</td>
      <td>❌ 긴 조건문으로 인해 가독성 저하</td>
      <td>✅ 각 전략은 역할이 명확, 읽기 쉬움</td>
    </tr>
    <tr>
      <td>**테스트 용이성**</td>
      <td>❌ 전체 조건 로직 묶여 있어 테스트 어려움</td>
      <td>✅ 전략별로 단위 테스트 가능</td>
    </tr>
  </tbody>
</table>

<h2 id="마무리">마무리</h2>

<p>조건문은 개발 초기엔 빠르게 구현할 수 있는 좋은 수단이지만,
복잡도가 커지는 시스템에서는 유지보수의 큰 장애물이 될 수 있습니다.</p>

<p>전략 패턴은 단순한 디자인 패턴이지만,
적재적소에 적용했을 때 코드의 유연성과 확장성을 극적으로 개선할 수 있습니다.</p>

<p>더 이상 if-else 지옥에 갇히지 마세요.
전략 패턴으로 깔끔하고 유지보수 쉬운 코드를 만들어 보세요!</p>]]></content><author><name>KIM-KYOUNG-OH</name></author><category term="Design-Pattern" /><category term="design-pattern" /><category term="spring" /><category term="java" /><category term="strategy-pattern" /><summary type="html"><![CDATA[개발자라면 한 번쯤은 if-else 문으로 가득한 클래스를 만들어본 적이 있을 겁니다. 하지만 시간이 지나고 코드가 커질수록, 우리는 더 깔끔하고 유연한 구조를 원하게 됩니다. 이번 포스팅에서 if-else 코드를 줄이면서 코드를 단순하고 유지보수에 유리한 구조로 변경하는 방법을 알아 보겠습니다.]]></summary></entry><entry><title type="html">Spring 개발자가 알아야 할 HTTP 통신 도구</title><link href="https://coffeetimes.github.io/jekyll-theme-yat/spring/2025/07/21/http_communication_tool.html" rel="alternate" type="text/html" title="Spring 개발자가 알아야 할 HTTP 통신 도구" /><published>2025-07-21T00:00:00+00:00</published><updated>2025-07-21T00:00:00+00:00</updated><id>https://coffeetimes.github.io/jekyll-theme-yat/spring/2025/07/21/http_communication_tool</id><content type="html" xml:base="https://coffeetimes.github.io/jekyll-theme-yat/spring/2025/07/21/http_communication_tool.html"><![CDATA[<p>Spring 기반 애플리케이션에서 외부 API와의 HTTP 통신은 매우 일반적인 작업입니다. 하지만 사용할 수 있는 도구가 다양하다 보니, <strong>어떤 도구를 언제 써야 할지 헷갈리는 경우가 많습니다.</strong></p>

<p>이번 글에서는 <strong>Spring 개발자가 알아야 할 주요 HTTP 통신 도구 5가지</strong>를 간단한 설명과 함께 정리해보았습니다.</p>

<h2 id="1resttemplate">1.RestTemplate</h2>

<p>오랫동안 사용된 고전적 동기 방식 Spring 표준 Http Client</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">RestTemplate</span> <span class="n">restTemplate</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">RestTemplate</span><span class="o">();</span>
<span class="nc">Order</span> <span class="n">order</span> <span class="o">=</span> <span class="n">restTemplate</span><span class="o">.</span><span class="na">getForObject</span><span class="o">(</span><span class="s">"https://api.example.com/orders/{id}"</span><span class="o">,</span> <span class="nc">Order</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">id</span><span class="o">);</span>
</code></pre></div></div>

<h4 id="장점">장점</h4>

<ul>
  <li>사용법이 간단하고 직관적</li>
  <li>오랜 기간 사용되어 안정적이며 간단한 REST 호출에 적합</li>
</ul>

<h4 id="단점">단점</h4>

<ul>
  <li>동기 방식만 지원 → 대규모 동시성 환경에서 성능 저하 발생</li>
  <li>Spring 5부터는 업데이트 중단(Deprecated)</li>
</ul>

<h2 id="webclient">WebClient</h2>

<p>Spring WebFlux의 비동기 &amp; 리액티브 HTTP 클라이언트</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">WebClient</span> <span class="n">client</span> <span class="o">=</span> <span class="nc">WebClient</span><span class="o">.</span><span class="na">create</span><span class="o">(</span><span class="s">"https://api.example.com"</span><span class="o">);</span>

<span class="nc">Mono</span><span class="o">&lt;</span><span class="nc">Order</span><span class="o">&gt;</span> <span class="n">orderMono</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="na">get</span><span class="o">()</span>
    <span class="o">.</span><span class="na">uri</span><span class="o">(</span><span class="s">"/orders/{id}"</span><span class="o">,</span> <span class="n">id</span><span class="o">)</span>
    <span class="o">.</span><span class="na">retrieve</span><span class="o">()</span>
    <span class="o">.</span><span class="na">bodyToMono</span><span class="o">(</span><span class="nc">Order</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
</code></pre></div></div>

<h4 id="장점-1">장점</h4>

<ul>
  <li>Non-Blocking/Reactive 패러다임 지원 → 높은 동시 처리 성능</li>
  <li>체이닝(Fluent) 방식의 체계적이고 직관적</li>
  <li>동기/비동기 모두 지원</li>
  <li>REST뿐만 아니라 웹소켓, SSE등 다양한 프로토콜 지원</li>
</ul>

<h4 id="단점-1">단점</h4>

<ul>
  <li>Reactive 프로그래밍 개념에 대한 러닝커브가 있음</li>
  <li>동기 방식보다 복잡한 예외 처리 필요</li>
</ul>

<h2 id="3restclient">3.RestClient</h2>

<p>Spring 6에서 새롭게 등장한 선언형 HTTP 클라이언트</p>

<p><code class="language-plaintext highlighter-rouge">RestTemplate</code> + <code class="language-plaintext highlighter-rouge">WebClient</code> 장점을 흡수한 현대적 API</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">RestClient</span> <span class="n">restClient</span> <span class="o">=</span> <span class="nc">RestClient</span><span class="o">.</span><span class="na">create</span><span class="o">(</span><span class="s">"https://api.example.com"</span><span class="o">);</span>

<span class="nc">Order</span> <span class="n">order</span> <span class="o">=</span> <span class="n">restClient</span><span class="o">.</span><span class="na">get</span><span class="o">()</span>
        <span class="o">.</span><span class="na">uri</span><span class="o">(</span><span class="s">"/orders/{id}"</span><span class="o">,</span> <span class="n">id</span><span class="o">)</span>
        <span class="o">.</span><span class="na">retrieve</span><span class="o">()</span>
        <span class="o">.</span><span class="na">body</span><span class="o">(</span><span class="nc">Order</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@RestClient</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">OrderClient</span> <span class="o">{</span>
    <span class="nd">@GetExchange</span><span class="o">(</span><span class="s">"/orders/{id}"</span><span class="o">)</span>
    <span class="nc">Order</span> <span class="nf">getOrder</span><span class="o">(</span><span class="nd">@PathVariable</span><span class="o">(</span><span class="s">"id"</span><span class="o">)</span> <span class="nc">Long</span> <span class="n">id</span><span class="o">);</span>
<span class="o">}</span>

<span class="c1">// 사용 예시</span>
<span class="nc">Order</span> <span class="n">order</span> <span class="o">=</span> <span class="n">orderClient</span><span class="o">.</span><span class="na">getOrder</span><span class="o">(</span><span class="mi">123L</span><span class="o">);</span>
</code></pre></div></div>

<h4 id="장점-2">장점</h4>

<ul>
  <li>RestTemplate 보다 심플하고 현대적인 동기식 API 제공</li>
  <li><strong>체이닝 기반 명령형 호출과 인터페이스 선언형 호출</strong> 모두 지원 가능</li>
  <li>Spring 6 내장 라이브러리 (추가 의존성 없음)</li>
</ul>

<h4 id="단점-2">단점</h4>

<ul>
  <li>Spring 6 이상에서만 사용 가능(구버전 호환 불가)</li>
  <li>생태계/레퍼런스/사례가 아직 제한적임</li>
</ul>

<h2 id="4httpclient">4.HttpClient</h2>

<p>JDK 내장 라이브러리</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">HttpClient</span> <span class="n">client</span> <span class="o">=</span> <span class="nc">HttpClient</span><span class="o">.</span><span class="na">newHttpClient</span><span class="o">();</span>
<span class="nc">HttpRequest</span> <span class="n">request</span> <span class="o">=</span> <span class="nc">HttpRequest</span><span class="o">.</span><span class="na">newBuilder</span><span class="o">()</span>
        <span class="o">.</span><span class="na">uri</span><span class="o">(</span><span class="no">URI</span><span class="o">.</span><span class="na">create</span><span class="o">(</span><span class="s">"https://api.example.com/orders/1"</span><span class="o">))</span>
        <span class="o">.</span><span class="na">build</span><span class="o">();</span>

<span class="nc">HttpResponse</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">response</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="na">send</span><span class="o">(</span><span class="n">request</span><span class="o">,</span> <span class="nc">BodyHandlers</span><span class="o">.</span><span class="na">ofString</span><span class="o">());</span>
</code></pre></div></div>

<h4 id="장점-3">장점</h4>

<ul>
  <li>JDK +11 내장 라이브러리이므로 외부 의존성 없이 바로 사용 가능</li>
  <li>동기/비동기 모두 지원</li>
  <li>HTTP/2, WebSocket 등 최신 프로토콜 지원</li>
  <li>저수준 레벨의 세부 제어 가능</li>
</ul>

<h4 id="단점-3">단점</h4>

<ul>
  <li>직접 모든 것을 처리해야함(직렬화, 예외 처리 등)</li>
  <li>생산성이 RestTemplate, WebClient 보다 낮을 수 있음</li>
  <li>JDK 11 이상 필요(구버전 호환 불가)</li>
</ul>

<h2 id="5feignclient-spring-cloud-openfeign">5.FeignClient (Spring Cloud OpenFeign)</h2>

<p>인터페이스 기반 선언형 HTTP 클라이언트<br />
<strong>OpenFeign</strong> 이라는 이름으로 <strong>Spring Cloud</strong> 의 일부로 통합되어 있음<br />
인터페이스에 애노테이션만 붙이면 API 호출 가능</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@FeignClient</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"orderClient"</span><span class="o">,</span> <span class="n">url</span> <span class="o">=</span> <span class="s">"https://api.example.com"</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">OrderClient</span> <span class="o">{</span>
    <span class="nd">@GetMapping</span><span class="o">(</span><span class="s">"/orders/{id}"</span><span class="o">)</span>
    <span class="nc">Order</span> <span class="nf">getOrder</span><span class="o">(</span><span class="nd">@PathVariable</span> <span class="nc">String</span> <span class="n">id</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<h4 id="장점-4">장점</h4>

<ul>
  <li>선언형(Declarative) 스타일로 코드가 간결하고 직관적임</li>
  <li>Spring Cloud Discovery, Load Balancer 등과의 연동이 우수함</li>
  <li>인터페이스만 정의하면 런타임에 구현체가 자동 생성되어 생산성이 높음</li>
</ul>

<h4 id="단점-4">단점</h4>

<ul>
  <li>동기 방식만 기본 지원(비동기 미지원)</li>
  <li>커스터마이징에 한계가 있음</li>
</ul>

<h2 id="비교-요약">비교 요약</h2>

<table>
  <thead>
    <tr>
      <th>라이브러리</th>
      <th>지원 방식</th>
      <th>동기/비동기</th>
      <th>장점</th>
      <th>단점</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>**RestTemplate**</td>
      <td>Spring 내장</td>
      <td>동기</td>
      <td>사용 쉬움, 문서 풍부</td>
      <td>동기만 지원, 신규 개발 비권장</td>
    </tr>
    <tr>
      <td>**WebClient**</td>
      <td>Spring Webflux 내장</td>
      <td>동기/비동기(주로 비동기)</td>
      <td>고성능, Reactive, 현대적</td>
      <td>러닝커브, 일부 복잡</td>
    </tr>
    <tr>
      <td>**RestClient**</td>
      <td>Spring 6+ 내장</td>
      <td>동기</td>
      <td>간결한 문법, 최신 표준</td>
      <td>Spring 6+ 한정, 자료 적음</td>
    </tr>
    <tr>
      <td>**HttpClient**</td>
      <td>JDK 11+ 내장</td>
      <td>동기/비동기</td>
      <td>외부 의존성 없음, 저수준 제어 용이</td>
      <td>Spring 통합 불편, 코드 많아짐</td>
    </tr>
    <tr>
      <td>**Feign Client**</td>
      <td>Spring Cloud 외부</td>
      <td>동기</td>
      <td>선언형, 마이크로서비스 최적</td>
      <td>동기 한정, 커스터마이즈 한계</td>
    </tr>
  </tbody>
</table>

<h2 id="마무리">마무리</h2>

<p>Spring 기반 애플리케이션에서 HTTP 통신을 구현하는 방법은 다양합니다.</p>

<p>각 라이브러리마다 특성이 다르므로, 프로젝트 환경과 목적에 맞는 도구를 선택하는 것이 중요합니다.</p>

<p>기술 선택은 <strong>프로젝트의 요구사항, 개발 조직의 지식 수준, 장기적인 유지보수</strong>까지 고려해 신중히 하세요.</p>

<p>최신 동향에 맞는 선택이 앞으로 더욱 효율적인 개발과 운영을 가능하게 합니다.</p>]]></content><author><name>KIM-KYOUNG-OH</name></author><category term="Spring" /><category term="http" /><category term="spring" /><category term="java" /><summary type="html"><![CDATA[Spring 기반 애플리케이션에서 외부 API와의 HTTP 통신은 매우 일반적인 작업입니다. 하지만 사용할 수 있는 도구가 다양하다 보니, 어떤 도구를 언제 써야 할지 헷갈리는 경우가 많습니다.]]></summary></entry><entry><title type="html">배포가 두렵다면? 무중단 배포 전략</title><link href="https://coffeetimes.github.io/jekyll-theme-yat/infra/2025/07/14/zero_downtime_deployment.html" rel="alternate" type="text/html" title="배포가 두렵다면? 무중단 배포 전략" /><published>2025-07-14T00:00:00+00:00</published><updated>2025-07-14T00:00:00+00:00</updated><id>https://coffeetimes.github.io/jekyll-theme-yat/infra/2025/07/14/zero_downtime_deployment</id><content type="html" xml:base="https://coffeetimes.github.io/jekyll-theme-yat/infra/2025/07/14/zero_downtime_deployment.html"><![CDATA[<p>서비스 배포할 때마다 손이 떨리고 로그창만 바라보며 기도하게 되시나요?<br />
“이거 올렸다가 터지면 어떡하지…” 하는 불안, 누구나 겪어봤을 겁니다.</p>

<p>하지만 걱정 마세요.<br />
<strong>다운타임 없이</strong>, <strong>문제 생겨도 빠르게 복구</strong>할 수 있는<br />
3가지 무중단 배포 전략을 소개합니다.</p>

<ol>
  <li>블루그린 배포 (Blue-Green)</li>
  <li>카나리 배포 (Canary)</li>
  <li>롤링 배포 (Rolling)</li>
</ol>

<h2 id="왜-무중단-배포를-도입해야하는가">왜 무중단 배포를 도입해야하는가?</h2>

<p>무중단 배포(Zero Downtime Deployment)의 가장 큰 목적은 <strong>서비스 중단 없이 안정적으로 새로운 버전을 배포하는 것</strong>입니다.</p>

<ul>
  <li><strong>고가용성(High Availability, HA)</strong>: 사용자에게 끊김 없는 경험 제공</li>
  <li><strong>안전한 롤백</strong>: 배포 실패 시 빠르게 이전 상태로 복구 가능</li>
  <li><strong>사용자 영향 최소화</strong>: 일부 사용자에게만 점진 적용 가능</li>
  <li><strong>배포 자동화와 일관성 확보</strong>: 실수 없이 반복 가능한 배포</li>
  <li><strong>빠른 피드백 루프</strong>: 자주 배포하고 즉시 개선할 수 있는 구조 지원</li>
</ul>

<p>서비스의 신뢰성과 배포 효율성을 동시에 잡기 위해 무중단 배포는 이제 선택이 아닌 <strong>필수 전략</strong>입니다.</p>

<h2 id="블루그린-배포-blue-green-deployment">블루그린 배포 (Blue-Green Deployment)</h2>

<p><strong>기존 운영 환경(Blue)</strong> 과 <strong>새로운 버전(Green)</strong> 을 <strong>동시에 운영</strong> 하며, <strong>새 버전(Green)</strong> 을 배포한 뒤, <strong>트래픽을 Green으로 전환</strong> 합니다. <br />
문제가 없다면 Green을 새로운 운영 환경으로 사용하고, 문제가 생기면 다시 Blue로 전환하여 <strong>즉시 롤백</strong> 이 가능합니다.</p>

<p><img src="https://github.com/user-attachments/assets/f02c4474-b314-4230-80cc-e8757937ea79" alt="Image" width="3016" height="1428" /></p>

<h3 id="장점">장점</h3>
<ul>
  <li>테스트 완료된 환경으로만 전환 → 안정적</li>
  <li>빠른 롤백</li>
</ul>

<h3 id="단점">단점</h3>
<ul>
  <li>블루, 그린 환경 2개 유지 필요 → <strong>높은 운영 비용</strong></li>
  <li>블루, 그린 모두 같은 데이터베이스를 바라보기 때문에 두 버전 모두 호환되도록 DB 스키마를 관리해야하고 점진적으로 마이그레이션 해야함 -&gt; <strong>DB 스키마 변경 시 관리 복잡</strong></li>
</ul>

<h3 id="활용-예시">활용 예시</h3>
<ul>
  <li>리스크가 큰 기능 출시</li>
  <li>빠른 롤백이 중요한 상황</li>
</ul>

<h2 id="카나리-배포-canary-deployment">카나리 배포 (Canary Deployment)</h2>

<p>카나리 배포(Canary Deployment)라는 이름은 과거 광산에서 ‘카나리아(canary)’ 새를 위험 신호 탐지에 활용한 것에서 유래했는데, 새가 먼저 유해 가스에 반응해 광부들이 신속히 대피할 수 있었기 때문입니다.  <br />
카나리 배포는 새 버전을 먼저 일부 사용자에게만 적용해 문제를 확인하고, 모니터링 이후에 이상 없으면 점차 모든 사용자에게 확대하는 점진적 배포 방식입니다.<br />
일부 실사용자에게만 새 버전을 노출하여 리스크를 점검하는 목적으로 사용합니다.</p>

<p><img src="https://github.com/user-attachments/assets/1d4ddb72-a07e-4a58-a211-4cdf0c83edf7" alt="Image" width="1041" height="529" /></p>

<h3 id="장점-1">장점</h3>
<ul>
  <li>사용자 중 일부만 새 버전을 먼저 사용 -&gt; <strong>실제 사용자 기반 테스트 가능</strong></li>
  <li>문제가 생겨도 영향 범위 제한</li>
</ul>

<h3 id="단점-1">단점</h3>
<ul>
  <li>트래픽 분할, 모니터링, 자동화 등 복잡한 운영 필요</li>
  <li>롤백이 단순 스위치가 아니라 점진적 롤백이므로 느림</li>
</ul>

<h3 id="활용-예시-1">활용 예시</h3>
<ul>
  <li>트래픽이 많은 서비스</li>
  <li>사용자 반응을 기반으로 기능 적용 여부 판단할 때</li>
</ul>

<h2 id="롤링-배포-rolling-deployment">롤링 배포 (Rolling Deployment)</h2>

<p>기존 서버 인스턴스를 <strong>하나씩 교체</strong>하며 새 버전을 배포하는 방법입니다.<br />
이 방식은 별도의 추가 환경을 마련하지 않고도 배포할 수 있기 때문에, 가용한 인프라 자원이 제한적인 상황에서 매우 효율적입니다.</p>

<p><img width="1599" height="662" alt="Image" src="https://github.com/user-attachments/assets/ba1a850e-6e09-4ef8-861e-38ce791a65e8" /></p>

<h3 id="장점-2">장점</h3>
<ul>
  <li>리소스 절약 (이중 환경 불필요)</li>
</ul>

<h3 id="단점-2">단점</h3>
<ul>
  <li>배포 중 구버전/신버전 혼재 가능</li>
  <li>문제 발생 시 점진적으로 반영되기 때문에 <strong>롤백이 느림</strong></li>
</ul>

<h3 id="활용-예시-2">활용 예시</h3>
<ul>
  <li>서버 자원이 제한적인 환경</li>
  <li>단일 서비스 운영 구조</li>
</ul>

<h2 id="전략별-비교-요약">전략별 비교 요약</h2>

<table>
  <thead>
    <tr>
      <th>전략</th>
      <th>다운타임 없음</th>
      <th>롤백 용이성</th>
      <th>리소스 비용</th>
      <th>배포 속도</th>
      <th>운영 복잡도</th>
      <th>사용자 영향 제어</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>블루그린</td>
      <td>✅</td>
      <td>높음 (즉시 롤백 가능)</td>
      <td>높음 (이중 환경 유지)</td>
      <td>빠름</td>
      <td>중간</td>
      <td>전체 사용자 전환</td>
    </tr>
    <tr>
      <td>카나리</td>
      <td>✅</td>
      <td>중간 (일부 점진적 롤백)</td>
      <td>중간 (부분 인스턴스 운영)</td>
      <td>느림</td>
      <td>높음</td>
      <td>일부 사용자 대상</td>
    </tr>
    <tr>
      <td>롤링</td>
      <td>✅</td>
      <td>낮음 (전체 점진적 롤백, 느림)</td>
      <td>낮음 (추가 환경 불필요)</td>
      <td>중간</td>
      <td>낮음</td>
      <td>전체 사용자 점진적 전환</td>
    </tr>
  </tbody>
</table>

<h2 id="어떤-전략을-선택해야-할까">어떤 전략을 선택해야 할까?</h2>

<table>
  <thead>
    <tr>
      <th>상황</th>
      <th>추천 전략</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>빠르게 롤백할 수 있어야 한다</td>
      <td>블루그린</td>
    </tr>
    <tr>
      <td>점진적으로 사용자 반응을 보고 싶다</td>
      <td>카나리</td>
    </tr>
    <tr>
      <td>리소스가 부족하다</td>
      <td>롤링</td>
    </tr>
  </tbody>
</table>

<h2 id="정리">정리</h2>

<p>무중단 배포가 아직 도입되지 않았다면, 서비스 환경과 리소스 상황에 맞춰 무중단 배포 전략을 선택하는 것을 권장합니다.</p>
<ul>
  <li>롤링 배포: 구현 쉽고 인프라 부담 적음. 자원 제한된 환경에 적합</li>
  <li>카나리 배포: 일부 사용자에 점진 적용, 리스크 관리에 효과적. 사용자 반응에 민감한 서비스 추천</li>
  <li>블루그린 배포: 완전 분리 환경, 즉시 롤백 가능. 대규모 서비스나 빠른 복구 필요 시 적합</li>
</ul>

<p>추가적으로 다음 키워드들도 무중단 배포 시스템을 더욱 고도화하는 데 도움이 될 수 있습니다.</p>
<ul>
  <li>Kubernetes 무중단 배포 전략</li>
  <li>Service Mesh</li>
  <li>Autoscaling</li>
  <li>Health Check</li>
  <li>Liveness/Readiness/Startup Probe</li>
</ul>

<h2 id="참고">참고</h2>

<p><a href="https://velog.io/@jingrow/%EB%B8%94%EB%A3%A8%EA%B7%B8%EB%A6%B0-%EB%A1%A4%EB%A7%81-%EC%B9%B4%EB%82%98%EB%A6%AC-%EB%B0%B0%ED%8F%AC%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90%EA%B3%BC-%EC%96%B4%EB%96%A4-%EA%B2%BD%EC%9A%B0%EC%97%90-%EA%B0%81%EA%B0%81%EC%9D%98-%EB%B0%B0%ED%8F%AC%EB%B0%A9%EC%8B%9D%EC%9D%84-%EC%8B%9C%EB%8F%84%ED%95%98%EB%8A%94%EC%A7%80-%EC%A1%B0%EC%82%AC%ED%95%B4%EB%B3%B4%EC%84%B8%EC%9A%94">https://velog.io/@jingrow</a></p>]]></content><author><name>KIM-KYOUNG-OH</name></author><category term="Infra" /><category term="zero-downtime-deployment" /><category term="infra" /><category term="CI/CD" /><summary type="html"><![CDATA[서비스 배포할 때마다 손이 떨리고 로그창만 바라보며 기도하게 되시나요? “이거 올렸다가 터지면 어떡하지…” 하는 불안, 누구나 겪어봤을 겁니다.]]></summary></entry><entry><title type="html">왜 테스트를 작성해야할까?</title><link href="https://coffeetimes.github.io/jekyll-theme-yat/test/2025/07/07/why_test.html" rel="alternate" type="text/html" title="왜 테스트를 작성해야할까?" /><published>2025-07-07T00:00:00+00:00</published><updated>2025-07-07T00:00:00+00:00</updated><id>https://coffeetimes.github.io/jekyll-theme-yat/test/2025/07/07/why_test</id><content type="html" xml:base="https://coffeetimes.github.io/jekyll-theme-yat/test/2025/07/07/why_test.html"><![CDATA[<p>개발을 하다 보면 “테스트 코드는 정말 꼭 작성해야 할까?”라는 질문을 종종 하게 됩니다. 하지만 시간이 지날수록, 기능이 많아지고 복잡도가 높아질수록 테스트 코드의 중요성은 점점 더 커집니다. 이번 글에서는 테스트 코드를 왜 작성해야 하는지, 그리고 각 테스트의 종류와 작성 방법에 대해 정리해 보겠습니다.</p>

<h2 id="테스트를-작성하는-이유">테스트를 작성하는 이유</h2>

<h3 id="1-회귀-테스트regression-test의-핵심-도구">1. 회귀 테스트(Regression Test)의 핵심 도구</h3>

<p>테스트 코드를 작성하는 가장 큰 이유 중 하나는 회귀 테스트입니다.</p>

<p>기능 개발 당시의 검증 목적도 있지만, 시간이 지난 후 기존 코드를 수정했을 때 예상치 못한 사이드 이펙트를 빠르게 발견할 수 있습니다.</p>

<p>즉, 테스트는 개발자가 놓치기 쉬운 부분을 자동으로 검증해주는 방어막 역할을 합니다.</p>

<h3 id="2-코드의-의도를-설명하는-문서">2. 코드의 의도를 설명하는 문서</h3>

<p>테스트 코드는 그 자체로도 하나의 문서입니다.</p>

<p>특정 기능이나 메서드가 어떤 조건에서 어떤 결과를 기대하는지를 테스트 코드만 봐도 알 수 있기 때문에, 코드를 이해하는 데 도움이 되는 중요한 단서가 됩니다.</p>

<h2 id="테스트의-종류">테스트의 종류</h2>

<p><img src="https://github.com/user-attachments/assets/691b614f-9646-47bf-a3f5-86ca431462f1" alt="스크린샷" /></p>

<p>테스트는 흔히 “테스트 피라미드” 구조로 분류됩니다. 아래로 갈수록 실행 속도는 빠르고, 위로 갈수록 실제 사용자 관점에 가까워집니다.</p>

<ol>
  <li>단위 테스트 (Unit Test)
    <ul>
      <li>하나의 메서드 또는 클래스 등 최소 단위의 로직을 테스트</li>
      <li>빠르고 독립적으로 실행됨</li>
    </ul>
  </li>
  <li>통합 테스트 (Integration Test)
    <ul>
      <li>DB, 외부 API 등 실제 인프라 또는 다른 모듈과의 연결을 포함한 테스트</li>
      <li>단위 테스트보다는 느리지만, 복잡한 흐름 검증 가능</li>
    </ul>
  </li>
  <li>E2E 테스트 (End-to-End Test)
    <ul>
      <li>브라우저나 앱을 통해 전체 사용자 플로우를 시나리오 기반으로 테스트</li>
      <li>실제 유저 관점에서 기능을 보장할 수 있음</li>
    </ul>
  </li>
</ol>

<h2 id="단위-테스트를-작성하는-방법">단위 테스트를 작성하는 방법</h2>

<ul>
  <li>Java 환경에서는 일반적으로 JUnit을 사용합니다.</li>
  <li>각 메서드의 입력과 출력을 검증하고, 의존성은 Mocking을 통해 격리합니다.</li>
  <li>예시 도구: <code class="language-plaintext highlighter-rouge">JUnit 5</code>, <code class="language-plaintext highlighter-rouge">Mockito</code>, <code class="language-plaintext highlighter-rouge">AssertJ</code></li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">org.junit.jupiter.api.Test</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">static</span> <span class="n">org</span><span class="o">.</span><span class="na">assertj</span><span class="o">.</span><span class="na">core</span><span class="o">.</span><span class="na">api</span><span class="o">.</span><span class="na">Assertions</span><span class="o">.*;</span>

<span class="kd">class</span> <span class="nc">PointServiceTest</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">PointService</span> <span class="n">pointService</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">PointService</span><span class="o">();</span>

    <span class="nd">@Test</span>
    <span class="kt">void</span> <span class="n">보유포인트보다_적은금액을_차감요청하면_정상적으로_차감된다</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">// given</span>
        <span class="kt">int</span> <span class="n">보유포인트</span> <span class="o">=</span> <span class="mi">1000</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">차감요청</span> <span class="o">=</span> <span class="mi">300</span><span class="o">;</span>

        <span class="c1">// when</span>
        <span class="kt">int</span> <span class="n">결과</span> <span class="o">=</span> <span class="n">pointService</span><span class="o">.</span><span class="na">deduct</span><span class="o">(</span><span class="n">보유포인트</span><span class="o">,</span> <span class="n">차감요청</span><span class="o">);</span>

        <span class="c1">// then</span>
        <span class="n">assertThat</span><span class="o">(</span><span class="n">결과</span><span class="o">).</span><span class="na">isEqualTo</span><span class="o">(</span><span class="mi">700</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Test</span>
    <span class="kt">void</span> <span class="n">보유포인트보다_많은금액을_차감요청하면_예외가_발생한다</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">// given</span>
        <span class="kt">int</span> <span class="n">보유포인트</span> <span class="o">=</span> <span class="mi">500</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">차감요청</span> <span class="o">=</span> <span class="mi">1000</span><span class="o">;</span>

        <span class="c1">// when &amp; then</span>
        <span class="n">assertThatThrownBy</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="n">pointService</span><span class="o">.</span><span class="na">deduct</span><span class="o">(</span><span class="n">보유포인트</span><span class="o">,</span> <span class="n">차감요청</span><span class="o">))</span>
                <span class="o">.</span><span class="na">isInstanceOf</span><span class="o">(</span><span class="nc">IllegalArgumentException</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
                <span class="o">.</span><span class="na">hasMessage</span><span class="o">(</span><span class="s">"보유 포인트보다 많이 차감할 수 없습니다."</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>

<h2 id="통합-테스트-작성하는-방법">통합 테스트 작성하는 방법</h2>

<p>통합 테스트는 실제 시스템 간 상호작용을 테스트합니다.</p>

<ul>
  <li>DB와 연동되는 테스트
    <ul>
      <li>테스트용 DB를 로컬에서 직접 사용하거나, Testcontainers를 활용하여 실제 DB 환경을 Docker로 띄우고 테스트할 수 있습니다.</li>
    </ul>
  </li>
  <li>외부 API와 연동되는 테스트
    <ul>
      <li>외부 API를 MockServer 또는 WireMock 등으로 가상화하거나, 실제 호출로 동작 확인</li>
    </ul>
  </li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@SpringBootTest</span>
<span class="nd">@Testcontainers</span>
<span class="kd">class</span> <span class="nc">UserRepositoryIntegrationTest</span> <span class="o">{</span>

    <span class="nd">@Container</span>
    <span class="kd">static</span> <span class="nc">PostgreSQLContainer</span><span class="o">&lt;?&gt;</span> <span class="n">postgresDB</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">PostgreSQLContainer</span><span class="o">&lt;&gt;(</span><span class="s">"postgres:13"</span><span class="o">)</span>
            <span class="o">.</span><span class="na">withDatabaseName</span><span class="o">(</span><span class="s">"testdb"</span><span class="o">)</span>
            <span class="o">.</span><span class="na">withUsername</span><span class="o">(</span><span class="s">"test"</span><span class="o">)</span>
            <span class="o">.</span><span class="na">withPassword</span><span class="o">(</span><span class="s">"test"</span><span class="o">);</span>

    <span class="nd">@Autowired</span>
    <span class="kd">private</span> <span class="nc">UserRepository</span> <span class="n">userRepository</span><span class="o">;</span>

    <span class="nd">@DynamicPropertySource</span>
    <span class="kd">static</span> <span class="kt">void</span> <span class="nf">overrideProps</span><span class="o">(</span><span class="nc">DynamicPropertyRegistry</span> <span class="n">registry</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">registry</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"spring.datasource.url"</span><span class="o">,</span> <span class="nl">postgresDB:</span><span class="o">:</span><span class="n">getJdbcUrl</span><span class="o">);</span>
        <span class="n">registry</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"spring.datasource.username"</span><span class="o">,</span> <span class="nl">postgresDB:</span><span class="o">:</span><span class="n">getUsername</span><span class="o">);</span>
        <span class="n">registry</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"spring.datasource.password"</span><span class="o">,</span> <span class="nl">postgresDB:</span><span class="o">:</span><span class="n">getPassword</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Test</span>
    <span class="kt">void</span> <span class="n">유저_엔티티를_저장하면_아이디로_조회할_수_있다</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">// given</span>
        <span class="nc">User</span> <span class="n">user</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">User</span><span class="o">();</span>
        <span class="n">user</span><span class="o">.</span><span class="na">setEmail</span><span class="o">(</span><span class="s">"test@example.com"</span><span class="o">);</span>

        <span class="c1">// when</span>
        <span class="n">userRepository</span><span class="o">.</span><span class="na">save</span><span class="o">(</span><span class="n">user</span><span class="o">);</span>

        <span class="c1">// then</span>
        <span class="nc">Optional</span><span class="o">&lt;</span><span class="nc">User</span><span class="o">&gt;</span> <span class="n">found</span> <span class="o">=</span> <span class="n">userRepository</span><span class="o">.</span><span class="na">findById</span><span class="o">(</span><span class="n">user</span><span class="o">.</span><span class="na">getId</span><span class="o">());</span>
        <span class="n">assertThat</span><span class="o">(</span><span class="n">found</span><span class="o">).</span><span class="na">isPresent</span><span class="o">();</span>
        <span class="n">assertThat</span><span class="o">(</span><span class="n">found</span><span class="o">.</span><span class="na">get</span><span class="o">().</span><span class="na">getEmail</span><span class="o">()).</span><span class="na">isEqualTo</span><span class="o">(</span><span class="s">"test@example.com"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@SpringBootTest</span>
<span class="nd">@AutoConfigureMockMvc</span>
<span class="nd">@TestInstance</span><span class="o">(</span><span class="nc">TestInstance</span><span class="o">.</span><span class="na">Lifecycle</span><span class="o">.</span><span class="na">PER_CLASS</span><span class="o">)</span>
<span class="kd">class</span> <span class="nc">WeatherServiceIntegrationTest</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">MockWebServer</span> <span class="n">mockWebServer</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">MockWebServer</span><span class="o">();</span>

    <span class="nd">@Autowired</span>
    <span class="kd">private</span> <span class="nc">WeatherService</span> <span class="n">weatherService</span><span class="o">;</span>

    <span class="nd">@DynamicPropertySource</span>
    <span class="kd">static</span> <span class="kt">void</span> <span class="nf">overrideBaseUrl</span><span class="o">(</span><span class="nc">DynamicPropertyRegistry</span> <span class="n">registry</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
        <span class="n">mockWebServer</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
        <span class="n">registry</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"weather.api.base-url"</span><span class="o">,</span> <span class="o">()</span> <span class="o">-&gt;</span> <span class="n">mockWebServer</span><span class="o">.</span><span class="na">url</span><span class="o">(</span><span class="s">"/"</span><span class="o">).</span><span class="na">toString</span><span class="o">());</span>
    <span class="o">}</span>

    <span class="nd">@BeforeEach</span>
    <span class="kt">void</span> <span class="nf">setupMockResponse</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">mockWebServer</span><span class="o">.</span><span class="na">enqueue</span><span class="o">(</span><span class="k">new</span> <span class="nc">MockResponse</span><span class="o">()</span>
                <span class="o">.</span><span class="na">setBody</span><span class="o">(</span><span class="sh">"""
                    {
                        "city": "Seoul",
                        "temperature": 26
                    }
                """</span><span class="o">)</span>
                <span class="o">.</span><span class="na">addHeader</span><span class="o">(</span><span class="s">"Content-Type"</span><span class="o">,</span> <span class="s">"application/json"</span><span class="o">));</span>
    <span class="o">}</span>

    <span class="nd">@Test</span>
    <span class="kt">void</span> <span class="n">도시명으로_날씨조회시_API호출후_온도반환</span><span class="o">()</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">weatherService</span><span class="o">.</span><span class="na">getWeather</span><span class="o">(</span><span class="s">"Seoul"</span><span class="o">);</span>
        <span class="n">assertThat</span><span class="o">(</span><span class="n">temp</span><span class="o">).</span><span class="na">isEqualTo</span><span class="o">(</span><span class="mi">26</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@AfterAll</span>
    <span class="kd">static</span> <span class="kt">void</span> <span class="nf">shutdown</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
        <span class="n">mockWebServer</span><span class="o">.</span><span class="na">shutdown</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="e2e-테스트-작성하는-방법">E2E 테스트 작성하는 방법</h2>

<ul>
  <li>전체 시스템이 실행된 상태에서 브라우저나 앱을 통해 사용자 시나리오를 그대로 따라가는 테스트</li>
  <li>실제 버튼 클릭, 페이지 이동 등 UI 이벤트 기반 테스트</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@SpringBootTest</span>
<span class="nd">@AutoConfigureMockMvc</span>
<span class="nd">@TestInstance</span><span class="o">(</span><span class="nc">TestInstance</span><span class="o">.</span><span class="na">Lifecycle</span><span class="o">.</span><span class="na">PER_CLASS</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">UserRegistrationE2ETest</span> <span class="o">{</span>

    <span class="nd">@Autowired</span>
    <span class="kd">private</span> <span class="nc">MockMvc</span> <span class="n">mockMvc</span><span class="o">;</span>

    <span class="nd">@Test</span>
    <span class="kt">void</span> <span class="n">회원가입_및_로그인_시나리오_테스트</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
        <span class="c1">// 1. 회원가입 요청</span>
        <span class="n">mockMvc</span><span class="o">.</span><span class="na">perform</span><span class="o">(</span><span class="n">post</span><span class="o">(</span><span class="s">"/api/users/register"</span><span class="o">)</span>
                <span class="o">.</span><span class="na">contentType</span><span class="o">(</span><span class="nc">MediaType</span><span class="o">.</span><span class="na">APPLICATION_JSON</span><span class="o">)</span>
                <span class="o">.</span><span class="na">content</span><span class="o">(</span><span class="sh">"""
                    {
                        "email": "test@example.com",
                        "password": "secure123!",
                        "nickname": "tester"
                    }
                """</span><span class="o">))</span>
                <span class="o">.</span><span class="na">andExpect</span><span class="o">(</span><span class="n">status</span><span class="o">().</span><span class="na">isOk</span><span class="o">());</span>

        <span class="c1">// 2. 로그인 요청 → JWT 반환</span>
        <span class="nc">MvcResult</span> <span class="n">result</span> <span class="o">=</span> <span class="n">mockMvc</span><span class="o">.</span><span class="na">perform</span><span class="o">(</span><span class="n">post</span><span class="o">(</span><span class="s">"/api/users/login"</span><span class="o">)</span>
                <span class="o">.</span><span class="na">contentType</span><span class="o">(</span><span class="nc">MediaType</span><span class="o">.</span><span class="na">APPLICATION_JSON</span><span class="o">)</span>
                <span class="o">.</span><span class="na">content</span><span class="o">(</span><span class="sh">"""
                    {
                        "email": "test@example.com",
                        "password": "secure123!"
                    }
                """</span><span class="o">))</span>
                <span class="o">.</span><span class="na">andExpect</span><span class="o">(</span><span class="n">status</span><span class="o">().</span><span class="na">isOk</span><span class="o">())</span>
                <span class="o">.</span><span class="na">andReturn</span><span class="o">();</span>

        <span class="nc">String</span> <span class="n">response</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="na">getResponse</span><span class="o">().</span><span class="na">getContentAsString</span><span class="o">();</span>
        <span class="nc">String</span> <span class="n">token</span> <span class="o">=</span> <span class="nc">JsonPath</span><span class="o">.</span><span class="na">read</span><span class="o">(</span><span class="n">response</span><span class="o">,</span> <span class="s">"$.token"</span><span class="o">);</span>

        <span class="c1">// 3. 로그인된 상태로 마이페이지 접근</span>
        <span class="n">mockMvc</span><span class="o">.</span><span class="na">perform</span><span class="o">(</span><span class="n">get</span><span class="o">(</span><span class="s">"/api/users/me"</span><span class="o">)</span>
                <span class="o">.</span><span class="na">header</span><span class="o">(</span><span class="s">"Authorization"</span><span class="o">,</span> <span class="s">"Bearer "</span> <span class="o">+</span> <span class="n">token</span><span class="o">))</span>
                <span class="o">.</span><span class="na">andExpect</span><span class="o">(</span><span class="n">status</span><span class="o">().</span><span class="na">isOk</span><span class="o">())</span>
                <span class="o">.</span><span class="na">andExpect</span><span class="o">(</span><span class="n">jsonPath</span><span class="o">(</span><span class="s">"$.email"</span><span class="o">).</span><span class="na">value</span><span class="o">(</span><span class="s">"test@example.com"</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="정리">정리</h2>

<ul>
  <li>테스트는 회귀 방지 + 문서 역할이라는 두 가지 이유만으로도 충분히 작성할 가치가 있습니다.</li>
  <li>테스트 피라미드 구조를 고려하여, 빠르고 신뢰할 수 있는 테스트 전략을 설계하는 것이 중요합니다.</li>
  <li>처음부터 완벽한 테스트 커버리지를 목표로 하기보다는, 가장 중요한 흐름부터 테스트를 작성하는 습관을 들이는 것이 핵심입니다.</li>
</ul>

<h2 id="참고">참고</h2>

<p><a href="https://semaphore.io/blog/testing-pyramid">https://semaphore.io/blog/testing-pyramid</a></p>]]></content><author><name>KIM-KYOUNG-OH</name></author><category term="Test" /><category term="test" /><summary type="html"><![CDATA[개발을 하다 보면 “테스트 코드는 정말 꼭 작성해야 할까?”라는 질문을 종종 하게 됩니다. 하지만 시간이 지날수록, 기능이 많아지고 복잡도가 높아질수록 테스트 코드의 중요성은 점점 더 커집니다. 이번 글에서는 테스트 코드를 왜 작성해야 하는지, 그리고 각 테스트의 종류와 작성 방법에 대해 정리해 보겠습니다.]]></summary></entry><entry><title type="html">항해 Plus 1주차 회고(WIL)</title><link href="https://coffeetimes.github.io/jekyll-theme-yat/%ED%9A%8C%EA%B3%A0/2024/12/22/hhplus_1st_week.html" rel="alternate" type="text/html" title="항해 Plus 1주차 회고(WIL)" /><published>2024-12-22T00:00:00+00:00</published><updated>2024-12-22T00:00:00+00:00</updated><id>https://coffeetimes.github.io/jekyll-theme-yat/%ED%9A%8C%EA%B3%A0/2024/12/22/hhplus_1st_week</id><content type="html" xml:base="https://coffeetimes.github.io/jekyll-theme-yat/%ED%9A%8C%EA%B3%A0/2024/12/22/hhplus_1st_week.html"><![CDATA[<p>항해 Plus 1주차 핵심 주제는 ‘클린 코드 &amp; 테스트’ 에 대한 내용이었습니다.</p>

<p>과제는 간단한 포인트 조회/적립 기능을 구현하는 API를 만들어보는 내용이었고 거기에 동시성 이슈까지 해결해보는 내용이었습니다.</p>

<h2 id="클린-코드">클린 코드</h2>

<p>최대한 <strong>책임의 분리 원칙</strong>을 초점으로 코드를 작성하기 위해 노력했습니다.</p>

<p>포인트 충전 함수의 로직은 크게 동시성 제어 로직과 포인트를 충전하는 DB IO 작업으로 나뉘어집니다. 동시성 제어 로직은 핵심 비즈니스와 관심사는 아니라고 판단하여 별도의 클래스로 책임을 분리하여 작성했습니다.</p>

<p>도메인 객체의 내부 성분은 외부로부터 캡슐화하고 객체 자신을 수정하는 로직은 도메인 클래스의 멤버 함수로 제공하는 방식을 사용했습니다.</p>

<h2 id="테스트">테스트</h2>

<p>단위 테스트와 통합 테스트의 사용 목적과 사용법에 대해서 익힐 수 있었습니다.</p>

<p>단위 테스트는 외부 의존성과 격리된 환경에서 순수 자기 자신만 테스트하는 것을 목적으로 하는 테스트입니다.</p>

<p>통합 테스트는 외부 의존성과 연동되어 전체적으로 시스템이 전반적으로 의도대로 동작하는지를 목적으로 하는 테스트입니다.</p>

<p>TDD라는 Test 먼저 작성하면서 비즈니스를 설계하는 방법론도 있지만 현업에선 불가능하다는 의견이 많습니다. 테스트도 결국 요구사항 분석과 도메인에 대한 이해가 바탕이 되어야 하기 때문입니다.</p>

<p>line coverage와 branch coverage 에 대해서도 학습할 수 있었는데 line coverage 100%는 불필요한 테스트까지 작성해야하기 때문에 현업에서는 채우기 어렵고 brach coverage 100% 까지는 현업에서 도입해볼만 하다고 생각됩니다.</p>

<p>branch coverage는 if와 같은 조건절 분기에 대한 참/거짓이 모두 실행되었는지를 측정하는 지표입니다.</p>

<h2 id="동시성-제어">동시성 제어</h2>

<p>해당 과제에서는 애플리케이션 레벨에서 동시성 문제를 해결하기 위한 방법에 초점을 맞췄습니다.</p>

<p>java Concurrent 패키지에서 지원하는 ConcurrentHashMap과 ReentrantLock을 사용해서 동시성 이슈를 해결했습니다.</p>

<p>ConcurrentHashMap은 세그먼트 단위로 자원에 대한 스레드 접근을 제어하기 때문에 Thread-safe를 보장하고 동시성 성능까지 높일 수 있는 자료구조 입니다.</p>

<p>ReentrantLock은 락 획득과 반납을 빌트인 함수로 간편하게 제공하고 이전 스레드가 락을 반납할 때까지 이후 스레드가 blocking되는 방식으로 구현됩니다.</p>

<p>단, 락이 반환되는 속도보다 요청이 쌓이는 속도가 더 빠른 환경에선 Thread Pool의 스레드가 마르거나 blocking 되는 자원이 커지면서 OOME가 발생할 우려가 있기 때문에 대규모 시스템에선 Zookeeper나 Redis 같은 독립된 인메모리 인스턴스를 사용해서 동시성 문제를 해결하는 방법도 고려해볼 수 있습니다.</p>

<h2 id="과제-소스코드-링크">과제 소스코드 링크</h2>

<p>👉 <a href="https://github.com/KIM-KYOUNG-OH/hhplus-1st-week">과제 메인 깃헙 레포지토리 Link</a></p>

<p>👉 <a href="https://github.com/KIM-KYOUNG-OH/hhplus-1st-week/pull/1">기본 과제 PR Link</a></p>

<p>👉 <a href="https://github.com/KIM-KYOUNG-OH/hhplus-1st-week/pull/2">동시성 이슈 테스트 보고서 작성 PR Link</a></p>

<h2 id="kpt-회고">KPT 회고</h2>

<h3 id="keep">Keep</h3>

<ul>
  <li>단위 테스트를 작성하는 습관</li>
  <li>동시성 이슈를 항상 고민해보는 습관</li>
</ul>

<h3 id="problem">Problem</h3>

<ul>
  <li>ReentrantLock 같은 경우는 fairness 문제가 있는데 기술 도입 전에 기술에 대한 깊이 있는 이해와 도입 이유가 분명해야한다</li>
  <li>기술을 나만의 언어로 설명할 수 있는 수준의 이해가 부족함</li>
</ul>

<h3 id="try">Try</h3>

<ul>
  <li>다음 동시성 이슈 문제 해결시 Compare And Swap 개념 도입</li>
  <li>ModelMapper를 이용한 레이어간 DTO 변환 로직 작성</li>
</ul>

<h2 id="과제-제출-결과">과제 제출 결과</h2>

<p><img src="https://github.com/user-attachments/assets/25987210-aa29-4ccd-a21d-979dd8903cec" alt="스크린샷 2024-12-23 000009" /></p>

<p><img src="https://github.com/user-attachments/assets/2508e65b-81d6-4dd0-b060-eb735332f91b" alt="스크린샷 2024-12-23 000910" /></p>

<p><img src="https://github.com/user-attachments/assets/8e6f73db-1d55-4165-b3ae-91bdc284de9a" alt="스크린샷 2024-12-23 000924" /></p>]]></content><author><name>KIM-KYOUNG-OH</name></author><category term="회고" /><category term="clean-code" /><category term="test" /><category term="concurrency-control" /><summary type="html"><![CDATA[항해 Plus 1주차 핵심 주제는 ‘클린 코드 &amp; 테스트’ 에 대한 내용이었습니다.]]></summary></entry><entry><title type="html">민감 데이터 관리하기 with HashiCorp Vault (1)</title><link href="https://coffeetimes.github.io/jekyll-theme-yat/infra/2024/11/04/vault.html" rel="alternate" type="text/html" title="민감 데이터 관리하기 with HashiCorp Vault (1)" /><published>2024-11-04T00:00:00+00:00</published><updated>2024-11-04T00:00:00+00:00</updated><id>https://coffeetimes.github.io/jekyll-theme-yat/infra/2024/11/04/vault</id><content type="html" xml:base="https://coffeetimes.github.io/jekyll-theme-yat/infra/2024/11/04/vault.html"><![CDATA[<p>이번 포스팅에선 application.yml 에서 주로 입력되는 DB 접속 정보, 각종 키, 파일 경로 등 외부에 공개되면 안되는 민감한 데이터들을 Vault를 이용해서 효율적으로 관리하는 방법을 알아보겠습니다.</p>

<h2 id="hashicorp-vault-와-spring-cloud-vault">HashiCorp Vault 와 Spring Cloud Vault</h2>

<p>Vault는 HashiCorp에서 개발한 민감 데이터 관리 솔루션입니다.</p>

<p>Spring Cloud Vault는 Spring Framework 환경에서 Vault를 쉽게 사용할 수 있도록 하는 Spring 확장 라이브러리입니다.</p>

<p>Spring Cloud Config 와 결합하면 Config 서버를 통해 중앙 집중화하여 모든 설정값을 한 곳에서 관리하고 동적 리프레시를 지원합니다.</p>

<h2 id="demo-서비스">Demo 서비스</h2>

<p>spring boot 프로젝트를 생성하고 간단한 API 를 생성했습니다.</p>

<p>해당 API를 호출하면 애플리케이션의 프로필에 맞게 application.yml의 민감 데이터를 콘솔창에 출력해주는 기능을 구현했습니다.</p>

<h3 id="samplecontroller">sampleController</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.demo.toyproject.controller</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">org.springframework.beans.factory.annotation.Value</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.web.bind.annotation.GetMapping</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.web.bind.annotation.RestController</span><span class="o">;</span>

<span class="nd">@RestController</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">sampleController</span> <span class="o">{</span>

    <span class="nd">@Value</span><span class="o">(</span><span class="s">"${credentials.very-sensitive-data}"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">verySensitiveData</span><span class="o">;</span>

    <span class="nd">@GetMapping</span><span class="o">(</span><span class="s">"/credentials"</span><span class="o">)</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">printCredentials</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"verySensitiveData = "</span> <span class="o">+</span> <span class="n">verySensitiveData</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="applicationyml">application.yml</h3>

<div class="language-yml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">credentials</span><span class="pi">:</span>
  <span class="na">very-sensitive-data</span><span class="pi">:</span> <span class="s">hello-world</span>
</code></pre></div></div>

<hr />

<h2 id="install-vault">Install Vault</h2>

<p>Chocolatey 패키지 매니저를 이용해서 vault 설치</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>choco <span class="nb">install </span>vault
</code></pre></div></div>

<h2 id="run-vault-server">Run Vault Server</h2>

<p>local에서 실행 가능한 dev server로 vault를 실행합니다.</p>

<p>dev server는 모든 데이터를 메모리에 저장합니다.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>vault server <span class="nt">-dev</span>
</code></pre></div></div>

<p><img src="https://github.com/user-attachments/assets/60531071-37b3-486a-bedf-02adc8e21ae9" alt="스크린샷 2024-11-04 003157" /></p>

<p>서버를 실행하면 VAULT_ADDR 과 Root Token 값을 주는데 이를 환경 변수로 설정합니다.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ $env</span>:VAULT_ADDR<span class="o">=</span><span class="s2">"http://127.0.0.1:8200"</span>
<span class="nv">$ $env</span>:VAULT_TOKEN<span class="o">=</span><span class="s2">"hvs.mawhL0heT2k6xxKoPCDvDb60"</span>

<span class="nv">$ </span><span class="nb">echo</span> <span class="nv">$env</span>:VAULT_ADDR
http://127.0.0.1:8200
<span class="nv">$ </span><span class="nb">echo</span> <span class="nv">$env</span>:VAULT_TOKEN
hvs.mawhL0heT2k6xxKoPCDvDb60
</code></pre></div></div>

<h2 id="vault-login">Vault login</h2>

<p>http://127.0.0.1:8200에 접속해서 크롬 브라우저를 통해 Vault 서버에 접속하거나 Vault CLI를 통해서 Vault 서버에 접속할 수 있습니다.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>vault login <span class="nv">$env</span>:VAULT_TOKEN
Success! You are now authenticated. The token information displayed below
is already stored <span class="k">in </span>the token helper. You <span class="k">do </span>NOT need to run <span class="s2">"vault login"</span>
again. Future Vault requests will automatically use this token.

Key                  Value
<span class="nt">---</span>                  <span class="nt">-----</span>
token                hvs.mawhL0heT2k6xxKoPCDvDb60
token_accessor       Ym3v5ztCLvDgcTPvZJNj7Uip
token_duration       ∞
token_renewable      <span class="nb">false
</span>token_policies       <span class="o">[</span><span class="s2">"root"</span><span class="o">]</span>
identity_policies    <span class="o">[]</span>
policies             <span class="o">[</span><span class="s2">"root"</span><span class="o">]</span>
</code></pre></div></div>

<p><img src="https://github.com/user-attachments/assets/0412179e-d515-47e0-886b-61fbaed7e5dd" alt="스크린샷 2024-11-04 005604" width="80%" height="80%" /></p>

<h2 id="write--read-secret">Write &amp; Read secret</h2>

<p>key-value 형태로 데이터를 저장하기 위해선 특정 경로에 secret engine을 활성화해야합니다.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>vault secrets <span class="nb">enable</span> <span class="nt">-path</span><span class="o">=</span>secret kv

<span class="nv">$ </span>vault kv put secret/myapp very-sensitive-data<span class="o">=</span><span class="s2">"hello-world"</span>

<span class="nv">$ </span>vault kv get secret/myapp
<span class="o">==</span> Secret Path <span class="o">==</span>
secret/data/myapp

<span class="o">=======</span> Metadata <span class="o">=======</span>
Key                Value
<span class="nt">---</span>                <span class="nt">-----</span>
created_time       2024-11-03T15:47:42.2360653Z
custom_metadata    &lt;nil&gt;
deletion_time      n/a
destroyed          <span class="nb">false
</span>version            1

<span class="o">===========</span> Data <span class="o">===========</span>
Key                    Value
<span class="nt">---</span>                    <span class="nt">-----</span>
very-sensitive-data    hello-world

<span class="nv">$ </span>vault kv get <span class="nt">-field</span><span class="o">=</span>very-sensitive-data secret/myapp
hello-world
</code></pre></div></div>

<h2 id="spring-vault-의존성-추가">Spring Vault 의존성 추가</h2>

<p>build.gradle 파일에 spring vault 의존성을 추가해줍니다.</p>

<div class="language-gradle highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">implementation</span> <span class="nl">group:</span> <span class="s1">'org.springframework.cloud'</span><span class="o">,</span> <span class="nl">name:</span> <span class="s1">'spring-cloud-starter-vault-config'</span><span class="o">,</span> <span class="nl">version:</span> <span class="s1">'4.1.3'</span>
</code></pre></div></div>

<h2 id="applicationyml-수정">application.yml 수정</h2>

<div class="language-yml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">spring</span><span class="pi">:</span>
  <span class="na">config</span><span class="pi">:</span>
    <span class="na">import</span><span class="pi">:</span> <span class="s">vault://</span>  <span class="c1"># Vault에서 구성 정보를 가져옴</span>
  <span class="na">cloud</span><span class="pi">:</span>
    <span class="na">vault</span><span class="pi">:</span>
      <span class="na">authentication</span><span class="pi">:</span> <span class="s">TOKEN</span>
      <span class="na">uri</span><span class="pi">:</span> <span class="s">http://localhost:8200</span>
      <span class="na">token</span><span class="pi">:</span> <span class="s">hvs.a19L3ykBBxQK72LCvlGn4C1L</span>
      <span class="na">kv</span><span class="pi">:</span>
        <span class="na">enabled</span><span class="pi">:</span> <span class="kc">true</span>
        <span class="na">backend</span><span class="pi">:</span> <span class="s">secret</span>
        <span class="na">application-name</span><span class="pi">:</span> <span class="s">myapp</span>

<span class="na">credentials</span><span class="pi">:</span>
  <span class="na">very-sensitive-data</span><span class="pi">:</span> <span class="s">${very-sensitive-data}</span>
</code></pre></div></div>

<h2 id="테스트">테스트</h2>

<p>api 실행결과, vault 서버로부터 데이터가 잘 출력되는 것을 확인할 수 있습니다.</p>

<p><img src="https://github.com/user-attachments/assets/2e76a1f3-cb13-4fd0-84d4-188a1d12572f" alt="스크린샷 2024-11-04 021747" /></p>

<h2 id="정리">정리</h2>

<p>이번 포스팅에선 간단히 로컬에서 vault를 실행해보고 key-value 형태로 값을 저장해보는 실습을 진행해보았습니다.
실제 실무에선 위와 같이 적용하기엔 다소 무리가 있고 다음 포스팅에서 좀 더 실무 환경 요구 사항에 적합하게 인프라를 구축해보겠습니다.</p>

<h2 id="참고">참고</h2>

<p><a href="https://developer.hashicorp.com/vault/docs">https://developer.hashicorp.com/vault/docs</a><br />
<a href="https://sg-choi.tistory.com/624">https://sg-choi.tistory.com/624</a></p>]]></content><author><name>KIM-KYOUNG-OH</name></author><category term="Infra" /><category term="vault" /><summary type="html"><![CDATA[이번 포스팅에선 application.yml 에서 주로 입력되는 DB 접속 정보, 각종 키, 파일 경로 등 외부에 공개되면 안되는 민감한 데이터들을 Vault를 이용해서 효율적으로 관리하는 방법을 알아보겠습니다.]]></summary></entry></feed>